‚úÖ Cria√ß√£o de tabelas:
-autores: Armazena os dados dos autores dos livros.
-livros: Registra os livros e seus respectivos autores.
-usuarios: Representa os alunos que realizam empr√©stimos.
-emprestimos: Controla os empr√©stimos e devolu√ß√µes dos livros.

‚úÖ Inser√ß√£o de Dados:
-Popula√ß√£o inicial do banco com autores, livros e usu√°rios.
-Registro de empr√©stimos, incluindo casos em andamento.

‚úÖ Consultas SQL Avan√ßadas:
-Consulta detalhada de empr√©stimos, exibindo nomes dos alunos, livros e autores.
-Listagem de todos os livros dispon√≠veis e seus respectivos autores.
-Consulta de alunos que realizaram empr√©stimos e os livros lidos por cada um.
-Identifica√ß√£o dos autores mais populares com base no n√∫mero de empr√©stimos.
-C√°lculo do tempo m√©dio de leitura dos alunos nos √∫ltimos 6 meses.

‚úÖ Fun√ß√µes PL/pgSQL:
calcular_multa(data_devolucao, data_prevista, taxa_diaria): Calcula a multa para devolu√ß√µes em atraso.
relatorio_leitura_dias(usuario_id): Gera um relat√≥rio dos livros lidos por um aluno nos √∫ltimos 6 meses.
popularidade_autores(): Retorna um ranking dos autores mais lidos.

‚úÖ Cria√ß√£o de Vis√£o (VIEW):
emprestimos_detalhados: Uma vis√£o que re√∫ne informa√ß√µes detalhadas sobre os empr√©stimos, facilitando consultas r√°pidas.
üõ† Tecnologias Utilizadas:
PostgreSQL
PL/pgSQL (para fun√ß√µes e procedimentos armazenados)
SQL para modelagem e consultas

üìñ O que foi aprendido?
Estrutura√ß√£o de um banco de dados relacional desde a modelagem at√© a implementa√ß√£o.
Uso de chaves estrangeiras para garantir integridade referencial.
Escrita de fun√ß√µes e procedures para automa√ß√£o de c√°lculos e relat√≥rios.
Aplica√ß√£o de joins e agrega√ß√µes para consultas mais eficientes.
Cria√ß√£o de views para facilitar a visualiza√ß√£o dos dados.
------------------------------------------------------------------------------------------------------------------------------------------------

Mais detalhado:

//No in√≠cio, foi preciso estruturar o banco de dados. Criei quatro tabelas principais:

CREATE TABLE autores (
    autor_id SERIAL PRIMARY KEY,
    nome_autor VARCHAR(100) NOT NULL
);
CREATE TABLE: Define uma nova tabela.
SERIAL PRIMARY KEY: Cria uma chave prim√°ria que se auto-incrementa.
VARCHAR(100) NOT NULL: Define um campo de texto de at√© 100 caracteres, que n√£o pode ficar vazio.


//Depois, criei a tabela livros, vinculando-a √† tabela de autores:

CREATE TABLE livros (
    livro_id SERIAL PRIMARY KEY,
    titulo VARCHAR(150) NOT NULL,
    autor_id INT REFERENCES autores(autor_id)
);


//Depois de criar as tabelas, adicionei alguns registros de exemplo usando o INSERT INTO:

INSERT INTO autores (nome_autor) VALUES ('Sophia'), ('Marcos'), ('Luis');

//Para inserir livros e associ√°-los aos autores:

INSERT INTO livros (titulo, autor_id) VALUES 
('Pequeno Pr√≠ncipe', 1),
('Di√°rio de um Banana', 2),
('Maus', 3);


//Com os dados no banco, precisei criar algumas consultas para facilitar o acesso √†s informa√ß√µes. Buscar todos os livros e seus autores

SELECT l.titulo AS nome_livro, a.nome_autor
FROM livros l
JOIN autores a ON l.autor_id = a.autor_id;

-SELECT: Define quais colunas ser√£o exibidas.
-AS: D√° um apelido para a coluna, tornando o resultado mais leg√≠vel.
-JOIN: Relaciona tabelas diferentes (neste caso, livros e autores).
-ON: Define a condi√ß√£o para juntar os dados.


//Listar os empr√©stimos com nomes dos alunos e livros. Essa consulta retorna uma lista de empr√©stimos, mostrando quem pegou o livro, qual livro foi emprestado e as datas envolvidas.

SELECT 
    u.nome_usuario AS aluno,
    l.titulo AS livro,
    e.data_emprestimo,
    e.data_devolucao
FROM emprestimos e
JOIN usuarios u ON e.usuario_id = u.usuario_id
JOIN livros l ON e.livro_id = l.livro_id;

//Criando fun√ß√µes para c√°lculos.Um dos desafios foi lidar com atrasos na devolu√ß√£o dos livros. Para isso, criei uma fun√ß√£o para calcular a multa com base nos dias de atraso:

CREATE OR REPLACE FUNCTION calcular_multa(
    data_devolucao DATE, 
    data_prevista DATE, 
    taxa_diaria NUMERIC
) RETURNS NUMERIC AS $$
DECLARE
    dias_atraso INT;
BEGIN
    dias_atraso := GREATEST(0, data_devolucao - data_prevista);
    RETURN dias_atraso * taxa_diaria;
END;
$$ LANGUAGE plpgsql;

